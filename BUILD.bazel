load("@rules_cc//cc:defs.bzl", "cc_binary", "cc_library")

cc_binary(
    name = "my_hello",
    srcs = ["my_hello.cc"],
    deps = [
        "@abseil-cpp//absl/flags:flag",
        "@abseil-cpp//absl/flags:parse",
        "@abseil-cpp//absl/log",
        "@abseil-cpp//absl/log:flags",
        "@abseil-cpp//absl/log:initialize",
        "@abseil-cpp//absl/status",
        "@abseil-cpp//absl/strings",
        "@abseil-cpp//absl/time",
    ],
)

# Libbpf build rules
filegroup(
    name = "libbpf_headers",
    srcs = glob(["libbpf/src/*.h"]),
)

filegroup(
    name = "libbpf_uapi_headers_files",
    srcs = glob(["libbpf/include/uapi/**/*.h"]),
)

cc_library(
    name = "libbpf_uapi_headers",
    hdrs = glob(["libbpf/include/uapi/**/*.h"]),
    includes = ["libbpf/include/uapi"],
)

cc_library(
    name = "libbpf",
    srcs = glob(
        ["libbpf/src/*.c", "libbpf/src/*.h", "libbpf/include/**/*.h"],
        exclude = ["libbpf/src/test_libbpf.c"],
    ),
    hdrs = glob(["libbpf/src/*.h"]),
    copts = [
        "-g",
        "-O2",
        "-Werror",
        "-Wall",
        "-std=gnu89",
        "-D_LARGEFILE64_SOURCE",
        "-D_FILE_OFFSET_BITS=64",
        "-Wno-unknown-warning-option",
        "-Wno-format-overflow",
        "-Wno-unused-command-line-argument",
        "-Wno-compare-distinct-pointer-types",
        "-Wno-unused-parameter",
        "-Wno-missing-field-initializers",
    ],
    includes = [
        "libbpf/src",
        "libbpf/include",
        "libbpf/include/uapi",
    ],
    linkopts = [
        "-lelf",
        "-lz",
    ],
    strip_include_prefix = "libbpf/src",
    include_prefix = "bpf",
    deps = [":libbpf_uapi_headers"],
)


# 1. Compile the BPF program to an object file.
# We use a genrule because native BPF rules are not standard in Bazel yet.
genrule(
    name = "nvme_trace_bpf_o",
    srcs = [
        "nvme_trace.bpf.c",
        "nvme_trace.h",
        "nvme_core.h",
        ":libbpf_headers",
        ":libbpf_uapi_headers_files",
    ],
    outs = ["nvme_trace.bpf.o"],
    cmd = """
        # Create a 'bpf' directory and copy libbpf headers there to satisfy <bpf/bpf_helpers.h>
        mkdir -p bpf
        for h in $(locations :libbpf_headers); do
            cp "$$h" bpf/
        done
        
        # Create 'linux' directory for uapi headers
        mkdir -p linux
        # Copy uapi headers. We filter for linux/ headers to avoid directory structure issues if glob returns more.
        # Assuming structure is include/uapi/linux/*.h in the source.
        # Flattening might be an issue if not careful, but here we just need 'linux/' prefix.
        for h in $(locations :libbpf_uapi_headers_files); do
            # Check if it is a linux header
            if [[ "$$h" == *"linux/"* ]]; then
                cp "$$h" linux/
            fi
        done

        clang -g -O2 -target bpf \
            -D__TARGET_ARCH_x86 \
            -I $$(dirname $(location nvme_core.h)) \
            -I . \
            -I $$(pwd) \
            -c $(location nvme_trace.bpf.c) \
            -o $@
    """,
)

# 2. Generate the BPF skeleton header using bpftool.
genrule(
    name = "nvme_trace_skel_h",
    srcs = [":nvme_trace.bpf.o"],
    outs = ["nvme_trace.skel.h"],
    # Assuming 'bpftool' is in the system PATH. 
    # For a hermetic build, you would build it from //bpftool.
    cmd = "bpftool gen skeleton $(location :nvme_trace.bpf.o) > $@",
)

# 3. Build the userspace binary.
cc_binary(
    name = "nvme_trace",
    srcs = [
        "nvme_trace.c",
        "nvme_trace.h",
        ":nvme_trace_skel_h",
    ],
    # includes = [""],
    deps = [
        ":libbpf",
    ],
    # Link against system libraries required by libbpf (elf, zlib)
    linkopts = ["-lelf", "-lz"],
)
